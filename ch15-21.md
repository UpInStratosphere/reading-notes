### #chapter 15 (Dynamic Programing)
- key features
  - differ from ordinary divide conquer in that it's not just combining solutions to subproblems. __*it applies when SUBPROBLEMS OVERLAPS - that is, when subproblems does more work than necessary, repeatedly solving the common subproblems.*__ A DP algorithm thus avoiding recomputing by saving itr answer in a table.

- top-down with memoization
  - write the procedure recursively in a natural manner, but modified to save the result of each subproblem(array).
  - **essentially a "depth-first search" of the subproblem graph.**
- bottom-up method
  - we sort the subproblems by size and solve them in size order, so solving any particular subproblem depends only on solving smaller subproblem.
  - **essentially a reverse topological sort of the subproblems.**

- longest common subsequence
  - a classic DP problem similar to those on leetcode
- code optimization
  - do we really need to keep full table of info? perhaps we only need to maintain the immediately preceding values.


### #chapter 16 (Greedy Algorithms)
- intro
  - make a locally optimal choice in the hope that it will lead to a globally optimal solution
  - classic application: Minimum-spanning-tree, Dijkstra's algorithm for shortest paths from a single source
- dp v. greedy
  - dp is good, but sometimes it might be an overkill
  - greedy works better when it is possible to reach optimal solution without having to first solve all subproblem.
  - can usually transform recursive structure to iterative one.
