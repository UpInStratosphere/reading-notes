### #chapter 15 (Dynamic Programing)
- key features
  - differ from ordinary divide conquer in that it's not just combining solutions to subproblems. __*it applies when SUBPROBLEMS OVERLAPS - that is, when subproblems does more work than necessary, repeatedly solving the common subproblems.*__ A DP algorithm thus avoiding recomputing by saving itr answer in a table.

- top-down with memoization
  - write the procedure recursively in a natural manner, but modified to save the result of each subproblem(array).
  - **essentially a "depth-first search" of the subproblem graph.**
- bottom-up method
  - we sort the subproblems by size and solve them in size order, so solving any particular subproblem depends only on solving smaller subproblem.
  - **essentially a reverse topological sort of the subproblems.**

- longest common subsequence
  - a classic DP problem similar to those on leetcode
- code optimization
  - do we really need to keep full table of info? perhaps we only need to maintain the immediately preceding values.


### #chapter 16 (Greedy Algorithms)
- intro
  - make a locally optimal choice in the hope that it will lead to a globally optimal solution
  - classic application: Minimum-spanning-tree, Dijkstra's algorithm for shortest paths from a single source
- dp v. greedy
  - dp is good, but sometimes it might be an overkill
  - greedy works better when it is possible to reach optimal solution without having to first solve all subproblem.
  - can usually transform recursive structure to iterative one.

### #chapter 21 (Graph Algorithms)
- BFS
  - how it works
    - computes the distance from s to each reachable vertices and produces a BF-tree.
    - discovers all vertices at distance k from s before discovering any vertices at distances k+1.
    - works for both directed and undirected graph
  - performace
    - O(V + E): total time devoted to queue is O(V) and the time devoted to scanning the list is O(E). 
  - Application: (1) Prim's minimum-spanning tree, (2) Dijkstra's single-source shortest-paths
  
- DFS
  - how it works
    - search deeper whenever possible
    - explores edges out of the most recently discovered vertex that still has unexplored edges leaving it. Once all of v's edges have been explored, the search backtracks to explore edges leaving the vertex from which v was discovered
    - performance also O(V + E). 
  - application
    - topological sort
    - strongly connected components
   
- Topological sort of DAG
  - a linear ordering of all its vertices such that if G contains an edge(u, v), then u appears before v in the ordering.
  - only applies to DAG becuase no ordering is possible if the graph has cycle.
    ```cpp
    call DFS to compute finishing times v.f for each vertex v
    as each vertex is finished, insert it onto the front of a linked list
    return the linked list.
    ```
- Miminum Spanning Tree(MST)
  - definition
    - find a subset of T among E that connects all vertices and the W(T) is minimized.
    - applis to CONNECTED, UNDIRECTED graph.
  - Algorithms
    - both algorithms use greedy approach. They differs in specific method used to find safe edge.
    - general approach
      - grow one edge at a time.
      - prior to each iteration, A is a subset of some MST.
      - at each step, we determine an edge that we can add to A "a safe edge" such that A and {u, v} is also a subset of minimum spanning tree. 
      - key is how we can find the safe edge: let A be a subset of E that is included in some minimum spanning tree for G, let (S, V - S) be any cut of G that respects A, and let (u, v) be a light edge (i.e. its weight is the minimum of any edge crossing the cut) crossing (S, V - S), then (u, v) is a safe for A.
  - Kruskal's algorithm
    - O(ElgV) using ordinary binary heap.
    - make each vertex a unique set (individual trees)
    - sort the edges by its weight (ElogE)
    - find the safe dge by finding, of all edges that connect any two trees in the forest, an edge (u, v) of least weight.
    - union the trees connected by the newly established edge after each step.
  - Prim's algorithm (BFS)
    - O(ElgV) using ordinary binary heap, O(E + VlogV) using Fibonacci heap, which improves over binary heap if V is much smaller than E.
    - resembles Dijkstra's shortest-paths algorithm.
    - edges in set A always form a single tree (unlike individual tress in K's algorithm)
    - at each step, vertices not in the tree reside in a min-priority queue based on the key. Key is the minimum weight of any edge connecting v to a vertex in the tree.
    - running time depends on how we implement the priority queue.

- Single-source shortest Paths
  - intro
    - basic idea is we relax edges at each step. keep track of the shortest-path estimate from source s to v.
    - algorithms differ in how many times it relaxes each edges and in what order.
  - unweighted graph - BFS
  - Weighted, directed acyclic graph (DAG)
    - topologically sort the vertices and relax each accordingly.
  - Weighted, directed cyclic graph 
    - Floyd-Warshall (DP)
      - can detect whether a negative-weight cycle is reachable from the source
    - Dijkstra's (greedy)
      - assumes that no negative weights input.
      - maitain a set S of vertices whose final shortest-path weights from the source s have already been determined. The algorithm repeatedly selects the vertex u among V - S with the minimum shortest-path estimate, adds u to S, and relax all edges leaving u.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
